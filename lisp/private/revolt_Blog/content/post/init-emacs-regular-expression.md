+++
title = "Emacs Regular Expression"
date = 2020-06-06T00:00:00+08:00
lastmod = 2020-06-10T16:40:56+08:00
draft = false
locale = "en_US"
+++

## The main function {#the-main-function}

-   ****query-replace-regexp****


### Test demo {#test-demo}

```html
<input type="text" name="username">
<input type="password" name="password">
<input type="text" name="email">
<input type="text" name="country">
```


## Basic Concept {#basic-concept}

正则表达式的交互开发,你可以使用 `re-builder` 命令,在一个分离的
buffer里提供即时的视觉反馈,更方便开发调试.


### Syntax of Regexps {#syntax-of-regexps}

了解下写正则表达式的规则.

正则表达式有一些语法,一些字符是特殊的结构,其余很普通.

普通字符是一个匹配到字符(别的也匹配不到)简单的正则表达式.

特殊字符有 `. * + ? [ ^ $ \`.

如果在一个字符的尾部替换需要使用 特殊字符 `]`.

如果在一个字符的内部替换需要使用 特殊字符 `-`.

`[:` 和 `:]` 将字符类包含在字符的替换当中.

其他出现在正则表达式的任何字符都是普通的,除非前面有 `\` 转义.

```text
    例如, 'f' 不是一个特殊字符,所以它是普通的,因此 'f' 是一个只能匹配到字符串'f'的正则表达式.
    
    它不能匹配到字符串 'fg',只能匹配到字符的一部分.

    因此, 'o' 是一个仅能匹配到 'o' 的正则表达式.
```

任何两个正则表达式 `a` 和 `b` 可以被连接起来.结果就是一个可以匹配
字符串的正则表达式.如果 `a` 匹配一定数量的字符串的开头, `b` 匹配其
余的字符.

一个简单的例子,我们可以连接正则表达式 `f` 和 `o` 来得到正则表达式
`fo`, 这样匹配到的只有字符 `fo`. 要想变得更猛点,你需要使用一些特殊
的正则表达式结构.


#### Regexp Special                                                                              :Special characters: {#regexp-special-special-characters}

打开 `M-x re-builder` 测试正则表达式的作用.

-   测试DEMO ---------- 测试 `.` 的作用
    
    ```text
    aabbccddeeffgg
    ```
    
    `.` 可以匹配任意单个字符(换行符除外).

-   测试DEMO2 ---------- 测试 `*` 的作用
    
    ```text
    asdkjhiksdnfld
    baaaaaaabbbbbbb
    ```
    
    `*` 是一个后缀运算符,意味着尽可能多的匹配前面的正则表达式.
    
    `a*` 表示匹配任意数量的 `a`,甚至是没有 `a`.
    
    但是假设正则表达式为 `ao*` , 只要带a 的都会被匹配到,即便是没有
    `o`,如果有o的话,它会尽可能多的匹配 `ao`.
    
    ```text
    aoaoaoa
    aooaaooa
    ```
    
    ```text
    caaar
    ```
    
    采用匹配规则 `ca*ar` 来进行匹配.
    
    这个时候 `ca*` 配置 `caaa`,让 `ar` 来匹配剩下 `r`,这很明显是错
    误的. `*` 会修改结构,让匹配模式的其余部分成为可能.也就是让
    `ca*` 匹配 `caa`, 然后让 `ar` 匹配剩下的 `ar`.

-   测试DEMO3 ---------- 测试 `+` 的作用
    
    这是一个后缀运算符,类似与 `*`, 除了它必须匹配前面的表达式至少一
    次.例如: `ca+r` 可以匹配字符串 `car` 和 `caaaar` 但是不能匹配到
    字符串 `cr`
    
    ```text
    cr
    car
    caaaar
    ```

-   测试DEMO4 ---------- 测试 `?` 的作用
    
    `?` 是一个后缀运算符,和 `*` 类似,但是必须匹配前面的表达式中的一
    个,或者都不匹配.例如: `ca?r` 匹配 `cr` 或者 `car`,别的也就啥也
    不匹配了.
    
    ```text
    car
    ca
    cr
    caaaar
    crrra
    ```
    
    `ca?r`

-   测试DEMO5 ---------- 测试 `*?` | `+?` | `??` 的作用
    
    `*` | `+` | `?` 都是非贪心运算符.
    
    那么哪些操作符尽可能最大量的匹配子字符串哪?哪些非贪心变体匹配尽
    可能少的子字符串哪?
    
    1.  `c[ad]*a`
        
        最小的结果就是 `ca`,最长的结果就以 `a` 为结尾,然后只要满足
        字符是 `a` 或者 `d` 中的一个字符就可以.
        
        ```text
        cdaaada
        caaadaadaa
        cadfa
        caddadadcaa
        ```
    
    2.  `c[ad]*?a`  ---------- 测试 `*?` 的作用
        
        `[ad]*?` ,假设 `*` 匹配到 `a?`,再接着假设, `a?` 里面的 `?`
        一个也不匹配,那结果就是 `ca`.
        
        `[ad]*?`,假设 `*` 匹配到 `d?`,再接着假设, `d?` 里面的 `?` 匹
        配的是 `d` ,那就过就是 `cda`.
        
        反正不管你怎么假设,它结尾必定是一个 `a`.

-   测试DEMO6 ---------- 测试 `[ ... ]` 的作用
    
    `[ ... ]` 是一个可替换的字符,从 `[` 开始,由 `]` 结束.比如
    `[ad]*` 可以匹配任意由 `a` 和 `b` 组成的任意字符串(包括空字符串).
    比如 `c[ad]*r`,既能匹配到 `cr`, `car`, `cdr`, `cadr`
    
    ```text
    cadr
    ```
    
    你也可以在一个字符替换里面包括字符范围,通过用 `-` 来连接它们.比
    如: `[a-z]` 匹配任意小写的 `ASCII` letter.范围也可以自由的用个
    人字符混在在一起,例如 `[a-z$%.]` ,这将会匹配任意小写的 ASCII 字
    母,或者 `$`, `%` ,或者 `.`.
    
    常用的正则表达式特殊字符在字符替换里面并不特殊.
    
    完全不同的字符集是特殊的内部字符替换: `]` | `_` | `^`.
    
    要想在字符替换里面包含一个 `]` ,你必须让它在第一个字符.例如:
    `[]a]` 匹配 `]` or `a`.
    
    要想包含一个 `_`, 可以在替换字符的开头或者结尾写 `_`,或者作为范
    围的上界.因此, `[]_]` 匹配所有的 `]` 和 `_`
    
    要想在替换字符里面包含一个 `^`, 你可以放在开头的任何地方.
    
    下面范围的概念只是针对于EMACS:
    
    1.  如果变量 `case-fold-seacrh` value is `non-nil` , `[a-z]`
        also matches upper-case letters.
    
    2.  一个范围不受语言环境的排列序列所影响: 它经常表示 codepoint之
        间的边界范围的字符集,所以 `[a-z]` 匹配的只有 ASCII 字母.
    
    3.  作为一个特殊案例,如果范围边界是 8位字节,其他范围边界应该是一
        个单字节字符,那这个范围匹配的只有单字节字符.
    
    4.  如果一个范围的下界高于它的上界,那这个范围就是空的,表示没有任
        何字符.比如: `[b-a]` 就会匹配失败.但 `[^b-a]` 会匹配任何字,
        包括 newline. 然而,下界应该至少高于上界, `[c-a]` 这种情况应
        该避免.
    
    一个替换字符也可以制定命名字符集.这是POSIX的特色.例如:
    `[[:ascii]]:` 会匹配任何 ASCII 字符.它应该像下面这样写:
    
    ```text
    [[:ascii:]]
    ```
    
    使用一个字符集等价于在那个集合里面提及每个字符.但是后者实际过程
    中并不可行,因为一些集合包含了上千个不同的字符.一个字符集不应该
    被视为范围的下界或者上界.

-   测试DEMO7 ---------- 测试 `[^ ... ]` 的作用
    
    `[^` 起始于互补的替换字符.这将匹配除了被指定的任何字符.因此,
    `[^a-z0-9A-Z]` 匹配除了数字和字母的所有字符.
    
    `^` 不是替换字符中的特殊字符,除非它是第一个字符. `^` 后面的字符
    被当作第一个字符处理.( `_` 和 `]` 也不是特殊的.)
    
    一个互补的替换字符可以匹配 newline, 除非 newline 被字符集提及不
    能被匹配到.可以对比编程中处理正则表达式的方法,例如 `grep`.
    
    你可以指定命名字符串集,就像在替换字符一样. 例如: `[^[:ascii:]]`
    匹配任何 非ASCII 字符.

-   测试DEMO8 ---------- 测试 `^` 的作用
    
    当匹配一个buffer的时候, `^` 匹配空字符串,但仅有行首的文本被匹
    配.(或者仅有具有访问权限的buffer的开头被匹配).否则它将不会匹配
    任何东西.因此, `^foo` 匹配一个出现在行首的 `foo`.
    
    当匹配一个字符串而不是buffer的时候, `^` 匹配字符串的开头 或者 newline 字符后面的
    部分.
    
    出于历史兼容性原因, `^` 仅可以被用于正则表达式的开头,或者 `\(`
    , `\(?:`, `\|` 之后.

-   测试DEMO9 ---------- 测试 `$` 的作用
    
    和 `^` 类似,但是仅匹配行尾(或者具备访问权限的buffer的行尾部),因
    此, `x+$` 匹配一个或者多个以 `x` 为结尾的字符串.
    
    当匹配字符串而不是buffer的时候, `$` 匹配字符串的末尾或者newline
    字符之前的部分.

-   测试DEMO10 ---------- 测试 `\` 的作用
    
    `\` 主要有2个函数:
    
    1.  它引用特殊字符(包括 `\`).
    2.  它介绍了附加的特殊结构.
        
        因为 `\` 引用了特殊字符, `\$` 是一个仅能匹配到 `$` 的正则表
        达式, `\[` 是仅能匹配到 `[` 的正则表达式,以此类推.
        
        注意 `\` 在读取Lisp 字符串的时候也有特殊含义,必须用 `\` 来进
        行引用.例如: 正则表达式匹配 `\` 字符是 `\\`. 想要写一个Lisp字符
        串包含字符 `\\`, Lisp语法需要你引用每一个带 `\` 的 `\`. 因此,匹
        配 `\` 的正则表达式的读取语法是 `\\\\`.
        
        所以要想匹配 `\a\a` ,你的正则表达式可以写成 `"\\\\.*a$"`

-   如果特殊字符的特殊含义没有场景,它们将会被视为普通字符.例
    如: `*foo` 将会被视为 `*`. 因为 `\` 不是特殊的内部替代
    字符,它不能移除具有特殊含义的 `_` and `]`. 当他们没有特
    殊含义的时候,也不能引用这些字符.在它们有特殊含义的地
    方, `\` 可以合法的放在这些字符的前面.例如, `[^\]`,
    `"[^\\]"`,这将匹配除了下划线在外的任意单个字符.
    
    在实际过程中,大多数的 `]` 出现在正则表达式关闭字符替代,
    因此很特殊.然而,有时候一个正则表达式可能尝试匹配一个带
    着 `[` 和 `]` 的复杂文字模式.
    
    在一些场景下,它可能必须仔细的解析这个正则,从明确哪
    个方括号来关闭字符交替开始.比如,现在给你一个 `[^][]]` ,
    它是由互补的字符替代 `[^][]`,(这将匹配没有方括号的任意
    单个字符),后面跟着一个文字 `]`.
    
    [     EMACS\_REGEX](~/.emacs.d/lisp/private/revolt_Blog/static/images/flameshot/emacs-regex.png)       
    
    这里指的是不匹配 `[` ,但是最终能匹配到 `]]]` 这种情况.
    
    额外的规则就是正则表达式的开头, `[` 是特殊的, 但 `]` 不
    是.直到最后一个未引用的 `[`, 之后我们处在一个字符替换中.
    `[` 不再是特殊的(除了 `[` 开始于一个新的字符集这种情
    况.),但是 `]` 是特殊的.除非 `]` 后面暂时跟着特殊字符
    `[` 或者 `[` 后面跟着一个 `^`,直到下一个不在字符集尾部
    的特殊 `]`. 字符替代最终会恢复正则表达式的普通语法.未引
    用的 `[` 是特殊的,但是 `]` 并不特殊.
    
    PS: 没有案例印证,这段话很傻逼.


## re-build {#re-build}

re-build 是一个让你可以交互式构建正则表达式,可以让你在屏幕上看到匹
配到了什么东西.

你可以自定义 `reb-re-syntax` 或者设置变量 `reb-re-syntax` 来兼容你
的匹配规则.
