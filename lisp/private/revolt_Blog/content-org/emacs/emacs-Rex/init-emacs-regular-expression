#+-*-mode: org;-*-
#+creator: Emacs 28.0.50 (Org mode 9.3 + ox-hugo)
#+hugo_with_locale: en
#+hugo_front_matter_format: toml
#+hugo_level_offset: 1
#+hugo_delete_trailing_ws:
#+hugo_section: post
#+hugo_bundle:
#+hugo_base_dir: ../../../
#+date: <2020-06-06 Sat>
#+hugo_tags: 
#+hugo_categories: 
#+Title: Emacs Regular Expression

** The main function
   
  - **query-replace-regexp**

*** Test demo
    
    #+BEGIN_SRC html
      <input type="text" name="username">
      <input type="password" name="password">
      <input type="text" name="email">
      <input type="text" name="country">
    #+END_SRC
    
    
** Basic Concept
   
   正则表达式的交互开发,你可以使用 =re-builder= 命令,在一个分离的
   buffer里提供即时的视觉反馈,更方便开发调试.

   
*** Syntax of Regexps
    
    了解下写正则表达式的规则.
    
    正则表达式有一些语法,一些字符是特殊的结构,其余很普通.
    
    普通字符是一个匹配到字符(别的也匹配不到)简单的正则表达式.

    特殊字符有 =. * + ? [ ^ $ \=.

    如果在一个字符的尾部替换需要使用 特殊字符 =]=.

    如果在一个字符的内部替换需要使用 特殊字符 =-=.
    
    =[:= 和 =:]= 将字符类包含在字符的替换当中.
    
    其他出现在正则表达式的任何字符都是普通的,除非前面有 =\= 转义.
    
    #+BEGIN_EXAMPLE
    例如, 'f' 不是一个特殊字符,所以它是普通的,因此 'f' 是一个只能匹配到字符串'f'的正则表达式.
    
    它不能匹配到字符串 'fg',只能匹配到字符的一部分.

    因此, 'o' 是一个仅能匹配到 'o' 的正则表达式.
    #+END_EXAMPLE
    
    任何两个正则表达式 =a= 和 =b= 可以被连接起来.结果就是一个可以匹配
    字符串的正则表达式.如果 =a= 匹配一定数量的字符串的开头, =b= 匹配其
    余的字符.
    
    一个简单的例子,我们可以连接正则表达式 =f= 和 =o= 来得到正则表达式
    =fo=, 这样匹配到的只有字符 =fo=. 要想变得更猛点,你需要使用一些特殊
    的正则表达式结构.
    
    
    
**** Regexp Special                                                                              :Special characters:
     
     打开 =M-x re-builder= 测试正则表达式的作用.

     - 测试DEMO ---------- 测试 =.= 的作用
       
       #+BEGIN_EXAMPLE
	 aabbccddeeffgg
       #+END_EXAMPLE
     
       =.= 可以匹配任意单个字符(换行符除外).
     
     - 测试DEMO2 ---------- 测试 =*= 的作用
       
       #+BEGIN_EXAMPLE
	 asdkjhiksdnfld
	 baaaaaaabbbbbbb
       #+END_EXAMPLE
       
       =*= 是一个后缀运算符,意味着尽可能多的匹配前面的正则表达式.
       
       =a*= 表示匹配任意数量的 =a=,甚至是没有 =a=.
       
       但是假设正则表达式为 =ao*= , 只要带a 的都会被匹配到,即便是没有
       =o=,如果有o的话,它会尽可能多的匹配 =ao=.

       #+BEGIN_EXAMPLE
	 aoaoaoa
	 aooaaooa
       #+END_EXAMPLE
       
       #+BEGIN_EXAMPLE
       caaar
       #+END_EXAMPLE
       
       采用匹配规则 =ca*ar= 来进行匹配.
       
       这个时候 =ca*= 配置 =caaa=,让 =ar= 来匹配剩下 =r=,这很明显是错
       误的. =*= 会修改结构,让匹配模式的其余部分成为可能.也就是让
       =ca*= 匹配 =caa=, 然后让 =ar= 匹配剩下的 =ar=.

     - 测试DEMO3 ---------- 测试 =+= 的作用
       
       这是一个后缀运算符,类似与 =*=, 除了它必须匹配前面的表达式至少一
       次.例如: =ca+r= 可以匹配字符串 =car= 和 =caaaar= 但是不能匹配到
       字符串 =cr=
       
       #+BEGIN_EXAMPLE
	 cr
	 car
	 caaaar
       #+END_EXAMPLE
     
     - 测试DEMO4 ---------- 测试 =?= 的作用
       
       =?= 是一个后缀运算符,和 =*= 类似,但是必须匹配前面的表达式中的一
       个,或者都不匹配.例如: =ca?r= 匹配 =cr= 或者 =car=,别的也就啥也
       不匹配了.
       
       #+BEGIN_EXAMPLE
	 car
	 ca
	 cr
	 caaaar
	 crrra
       #+END_EXAMPLE
       
      =ca?r=

     - 测试DEMO5 ---------- 测试 =*?= | =+?= | =??= 的作用
       
       =*= | =+= | =?= 都是非贪心运算符.

       那么哪些操作符尽可能最大量的匹配子字符串哪?哪些非贪心变体匹配尽
       可能少的子字符串哪?
       
       1. =c[ad]*a=
	  
	  最小的结果就是 =ca=,最长的结果就以 =a= 为结尾,然后只要满足
          字符是 =a= 或者 =d= 中的一个字符就可以.

          #+BEGIN_EXAMPLE
	    cdaaada
	    caaadaadaa
	    cadfa
	    caddadadcaa
          #+END_EXAMPLE
       
       2. =c[ad]*?a=  ---------- 测试 =*?= 的作用

	  =[ad]*?= ,假设 =*= 匹配到 =a?=,再接着假设, =a?= 里面的 =?=
          一个也不匹配,那结果就是 =ca=.
	  
	  =[ad]*?=,假设 =*= 匹配到 =d?=,再接着假设, =d?= 里面的 =?= 匹
          配的是 =d= ,那就过就是 =cda=.
	  
	  反正不管你怎么假设,它结尾必定是一个 =a=.

     - 测试DEMO6 ---------- 测试 =[ ... ]= 的作用
       
       =[ ... ]= 是一个可替换的字符,从 =[= 开始,由 =]= 结束.比如
       =[ad]*= 可以匹配任意由 =a= 和 =b= 组成的任意字符串(包括空字符串).
       比如 =c[ad]*r=,既能匹配到 =cr=, =car=, =cdr=, =cadr=

       #+BEGIN_EXAMPLE
       cadr
       #+END_EXAMPLE
    
       你也可以在一个字符替换里面包括字符范围,通过用 =-= 来连接它们.比
       如: =[a-z]= 匹配任意小写的 =ASCII= letter.范围也可以自由的用个
       人字符混在在一起,例如 =[a-z$%.]= ,这将会匹配任意小写的 ASCII 字
       母,或者 =$=, =%= ,或者 =.=.
       
       常用的正则表达式特殊字符在字符替换里面并不特殊.
       
       完全不同的字符集是特殊的内部字符替换: =]= | =_= | =^=.

       要想在字符替换里面包含一个 =]= ,你必须让它在第一个字符.例如:
       =[]a]= 匹配 =]= or =a=.
       
       要想包含一个 =_=, 可以在替换字符的开头或者结尾写 =_=,或者作为范
       围的上界.因此, =[]_]= 匹配所有的 =]= 和 =_=
    
       要想在替换字符里面包含一个 =^=, 你可以放在开头的任何地方.
       
       下面范围的概念只是针对于EMACS:
       
       1. 如果变量 =case-fold-seacrh= value is =non-nil= , =[a-z]=
          also matches upper-case letters.

       2. 一个范围不受语言环境的排列序列所影响: 它经常表示 codepoint之
          间的边界范围的字符集,所以 =[a-z]= 匹配的只有 ASCII 字母.

       3. 作为一个特殊案例,如果范围边界是 8位字节,其他范围边界应该是一
          个单字节字符,那这个范围匹配的只有单字节字符.

       4. 如果一个范围的下界高于它的上界,那这个范围就是空的,表示没有任
          何字符.比如: =[b-a]= 就会匹配失败.但 =[^b-a]= 会匹配任何字,
          包括 newline. 然而,下界应该至少高于上界, =[c-a]= 这种情况应
          该避免.

       一个替换字符也可以制定命名字符集.这是POSIX的特色.例如:
       ~[[:ascii]]:~ 会匹配任何 ASCII 字符.它应该像下面这样写:
       
       #+BEGIN_EXAMPLE
	 [[:ascii:]]
       #+END_EXAMPLE
	  
       使用一个字符集等价于在那个集合里面提及每个字符.但是后者实际过程
       中并不可行,因为一些集合包含了上千个不同的字符.一个字符集不应该
       被视为范围的下界或者上界.
       
     - 测试DEMO7 ---------- 测试 =[^ ... ]= 的作用
       
       =[^= 起始于互补的替换字符.这将匹配除了被指定的任何字符.因此,
       =[^a-z0-9A-Z]= 匹配除了数字和字母的所有字符.

       =^= 不是替换字符中的特殊字符,除非它是第一个字符. =^= 后面的字符
       被当作第一个字符处理.( =_= 和 =]= 也不是特殊的.)

       一个互补的替换字符可以匹配 newline, 除非 newline 被字符集提及不
       能被匹配到.可以对比编程中处理正则表达式的方法,例如 =grep=.
       
       你可以指定命名字符串集,就像在替换字符一样. 例如: =[^[:ascii:]]=
       匹配任何 非ASCII 字符.
       
     - 测试DEMO8 ---------- 测试 =^= 的作用
       
       当匹配一个buffer的时候, =^= 匹配空字符串,但仅有行首的文本被匹
       配.(或者仅有具有访问权限的buffer的开头被匹配).否则它将不会匹配
       任何东西.因此, =^foo= 匹配一个出现在行首的 =foo=.

       当匹配一个字符串而不是buffer的时候, =^= 匹配字符串的开头 或者 newline 字符后面的
       部分.
       
       出于历史兼容性原因, =^= 仅可以被用于正则表达式的开头,或者 =\(=
       , =\(?:=, =\|= 之后.
       
     - 测试DEMO9 ---------- 测试 =$= 的作用

       和 =^= 类似,但是仅匹配行尾(或者具备访问权限的buffer的行尾部),因
       此, =x+$= 匹配一个或者多个以 =x= 为结尾的字符串.

       当匹配字符串而不是buffer的时候, =$= 匹配字符串的末尾或者newline
       字符之前的部分.
       
     - 测试DEMO10 ---------- 测试 =\= 的作用
     
       =\= 主要有2个函数:
       
       1. 它引用特殊字符(包括 =\=).
       2. 它介绍了附加的特殊结构.
	  
	  因为 =\= 引用了特殊字符, =\$= 是一个仅能匹配到 =$= 的正则表
          达式, =\[= 是仅能匹配到 =[= 的正则表达式,以此类推.
	  
	  注意 =\= 在读取Lisp 字符串的时候也有特殊含义,必须用 =\= 来进
          行引用.例如: 正则表达式匹配 =\= 字符是 =\\=. 想要写一个Lisp字符
          串包含字符 =\\=, Lisp语法需要你引用每一个带 =\= 的 =\=. 因此,匹
          配 =\= 的正则表达式的读取语法是 =\\\\=.

	  所以要想匹配 =\a\a= ,你的正则表达式可以写成 ="\\\\.*a$"=
	  
     - NOTE ::
	       如果特殊字符的特殊含义没有场景,它们将会被视为普通字符.例
               如: =*foo= 将会被视为 =*=. 因为 =\= 不是特殊的内部替代
               字符,它不能移除具有特殊含义的 =_= and =]=. 当他们没有特
               殊含义的时候,也不能引用这些字符.在它们有特殊含义的地
	       方, =\= 可以合法的放在这些字符的前面.例如, =[^\]=,
               ="[^\\]"=,这将匹配除了下划线在外的任意单个字符.

	       在实际过程中,大多数的 =]= 出现在正则表达式关闭字符替代,
               因此很特殊.然而,有时候一个正则表达式可能尝试匹配一个带
               着 =[= 和 =]= 的复杂文字模式.
	       
	       在一些场景下,它可能必须仔细的解析这个正则,从明确哪
               个方括号来关闭字符交替开始.比如,现在给你一个 =[^][]]= ,
               它是由互补的字符替代 =[^][]=,(这将匹配没有方括号的任意
               单个字符),后面跟着一个文字 =]=.
	       
	       #+RESULTS: sequenceDiagram
          [[file:~/.emacs.d/lisp/private/revolt_Blog/static/images/flameshot/emacs-regex.png][     EMACS_REGEX]]       
     
               这里指的是不匹配 =[= ,但是最终能匹配到 =]]]= 这种情况.
	       
               额外的规则就是正则表达式的开头, =[= 是特殊的, 但 =]= 不
               是.直到最后一个未引用的 =[=, 之后我们处在一个字符替换中.
               =[= 不再是特殊的(除了 =[= 开始于一个新的字符集这种情
               况.),但是 =]= 是特殊的.除非 =]= 后面暂时跟着特殊字符
               =[= 或者 =[= 后面跟着一个 =^=,直到下一个不在字符集尾部
               的特殊 =]=. 字符替代最终会恢复正则表达式的普通语法.未引
               用的 =[= 是特殊的,但是 =]= 并不特殊.

	       PS: 没有案例印证,这段话很傻逼.
             
	 
**** COMMENT scratch demo     
     
     #+BEGIN_EXAMPLE
       foo
       ;;-------------------- Remake-



       asdasd
       asd
       我你妈
       e13e easdase eaasdae asdasdaedawesa
       ee
       eee
       eeeee
       eeeeeeeeeeeee
       eeeeeeeeeefeeeee

       \\\\\

       \a\a

       \\\\asdas\as\dasd

       [[asdaadas[[][]]]]
       [[asdaadas[[][]]]ad]

       既不是 ]
       也不是 []
       非 ]
       非[]

     #+END_EXAMPLE
	       
               
       
** re-build
   
   re-build 是一个让你可以交互式构建正则表达式,可以让你在屏幕上看到匹
   配到了什么东西.

   你可以自定义 =reb-re-syntax= 或者设置变量 =reb-re-syntax= 来兼容你
   的匹配规则.

