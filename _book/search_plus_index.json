{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 融会贯通，想我所想，做我所做，遨游天地 "},"concept/":{"url":"concept/","title":"webpack concept","keywords":"","body":"wbpack basic concept webpack的基本概念 "},"concept/1-entry.html":{"url":"concept/1-entry.html","title":"1.1. 入口点","keywords":"","body":"Entry Entry 属性,有多种方式来定义. Single Entry{速记} 语法 Usage: entry: string | [string] module.exports = { entry: './path/to/my/entry/file.js' }; 对于 entry 属性 ,单个 entry 语法可简记为: module.exports = { entry: { main: './path/to/my/entry/file.js' } }; 当你给 entry 传递数组的时候会发生什么? 在给 =entry= 属性 传递一个文件路径数组过程中,会创建视为 =multi-main entry=. 当你想一起注入多个依赖文件,并且图形化它们的依赖到一个 =chunk= (组块)当中,这是非常有用的. 这个方式并不是特别灵活. Object Syntax Usage: entry: { string | [string] } //webpack.config.js //-------------------------------------------- module.exports = { entry: { app: './src/app.js', adminApp: './src/adminApp.js' } }; 这个 object syntax 更加冗余,但这是在应用中定义 entry/entries 最具拓展性的方式. Scalable webpack configuration 是一种可以重用和包含其他不完整的配置. 这是一种受欢迎的技术,通过 environment / build target/ runtime 被用于分离关注事项.他们也可以通过特殊工具来合并起来,比如使用 webpack-merge. Scenarios(情境) Separate APP and Vendor(供应商) Entries 这主要有 3个文件 webpack.config.js module.exports = { entry: { main: './src/app.js', vendor: './src/vendor.js' } }; webpack.prod.js (生产环境的配置) module.exports = { output: { filename: '[name].[contentHash].bundle.js' } }; webpack.dev.js (开发环境的配置) module.exports = { output: { filename: '[name].bundle.js' } }; 现在的情况就是,我们告诉webpack. 有2个分离的入口点,为毛这么干哪, JS里面有很多库,妈的,有些库你不必管它. 给你弄个 threeJS 的库,估计每个10天半个月也看不懂.所以把这些库看成死物.放在 vendor.js 里面就可以了. 它们将会捆绑在一起,然后放到它们的(组块) chunk当中. -content hash 是一样的,允许浏览器单独缓存它们,从而减少载入的时间. main: app.js vendor: vendor.js // 放一些 JQUERY/THREEJS/BOOTSTRAP 的库. webpack4 版本以下,通常添加 vendor 作为 separate entry point 来编译它作为 separate file.(与 CommonsChunkPlugin 相结合). webpack4 不建议这么做, optimization.splitChunks option 关心 separating vendors and app modules, AND creating a separate file. 所以不必为一个vendors 或其他东西 创建一个 entry了,这也不是执行操作的起点. Multi Page Application module.exports = { entry: { pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' } }; 这样就是告诉 webpack 我们想有 3个分离的依赖图示. 在单页面应用中,服务器在为你 fetch一个新的HTML document过程中,这个页面会重载 新的document , assets 会被重新下载. 这给我们唯一的选择来做这件事情,比如说使用 optimization.splitChunks 来创建捆绑包,从而在每个页面间的分享应用代码. Multi-Page 应用随着 entry point 的数量增加,可以在entry point 之间可以重复使用大量的代码 和 模块,受到了这项技术的巨大益处. "},"concept/2-output.html":{"url":"concept/2-output.html","title":"1.2. 输出点","keywords":"","body":"Table of Contents Output Usage Multiple Entry Points Advanced Output 配置 output 属性就是告诉webpack如何写编译好的文件输出到磁盘.注意,尽管可以设置多个 entry point,但是仅可以有一个 ouput 被指定. Usage 最小配置如下: module.exports = { output: { filename: 'bundle.js', } }; Multiple Entry Points 如果你配置创建了多个 chunk (因为携带了多个 entry point 或者当你使用 plugins ,比如 CommonsChunkPlugin的时候). 你应该使用 substitution (替换) 来确保每个文件都有一个独一无二的名字. module.exports = { entry: { app: './src/app.js', search: './src/search.js' }, output: { filename: '[name].js', path: __dirname + '/dist' } }; // writes to disk: ./dist/app.js, ./dist/search.js Advanced 下面是对 assets使用CND 和 hashes的例子. config.js ------------------------------ module.exports = { //... output: { path: '/home/proj/cdn/assets/[hash]', publicPath: 'https://cdn.example.com/assets/[hash]/' } }; 在编译时间过程中, outputfile 的 最终 publicPath 不知道的情况下, pubilcPath 能空着并且动态设置. __webpack_public_path__ = myRuntimePublicPath; // 其余的应用入口 "},"concept/3-loaders.html":{"url":"concept/3-loaders.html","title":"1.3. loaders","keywords":"","body":"Table of Contents Loaders Example Using Loaders Configuration Resolving Loaders Loaders Loaders 是一个转换器.被应用在一个模块的源代码上. 它们允许你 预处理 pro-process 文件作为你 import or load them. 因此,loaders 是一个像 处理 前端构建步骤的 \"tasks\". Loaders 可以转换来自不同语言的files 成为JS.也可以载入内联图片作为 data URLS. Loaders甚至允许你做一些事情,比如: 直接从你的JS模块里面 import CSS files. Example 可以告诉webpack 载入 css 文件,或者转换typescript 成为 JavaScript. 要想做这个你得先安装loaders. npm install --save-dev css-loader ts-loader 然后,就会通知webpack 对每个 .css 文件来使用 css-loader 了. 这种的话,需要写规则. webpack.config.js ------------------------------------------ module.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' } ] } }; Using Loaders 有3个法来使用loaders. Configuration: 直接在 webpack.config.js 里面配置就可以. Inline: 这种的话,需要在每个 import 声明中明确指定. CLI: 命令行操作. Configuration module.rules 允许你在你的webpack配置当中 指定一些loaders. 这是一种展示 loaders的简式方法,可以帮助你维护干净的代码.它也为你提供了各个loader的全部预览. Loaders 从右到左/从下到上 被评估/执行, 比如,先从 sass-loader,继续从 css-loader 执行,最终是=style-loader=. module.exports = { module: { rules: [ { test: /\\.css$/, use: [ // style-loader { loader: 'style-loader' }, // css-loader { loader: 'css-loader', options: { modules: true } }, // sass-loader { loader: 'sass-loader' } ] } ] } }; INLINE and CLI 的模式先不用了.没必要搞个麻烦的例子. Resolving Loaders loaders 使用 npm 来管理. "},"concept/4-plugins.html":{"url":"concept/4-plugins.html","title":"1.4. 插件","keywords":"","body":"Table of Contents Plugins Anatomy(解析) Usage Configuration NODE API Plugins Plugin 是 webpack里面的骨干. Anatomy(解析) webpack plugin 是一个 JS 对象,有 apply方法. 这个apply方法在webpack编译的时候被调用,给予整个编译生命周期的访问. ConsoleLogOnBuildWebpackPlugin.js Usage 因为plugin 可以携带 arguments/options,你必须给 plugins 属性传递一个新的实例. Configuration const HtmlWebpackPlugin = require('html-webpack-plugin'); //installed via npm const webpack = require('webpack'); //to access built-in plugins const path = require('path'); module.exports = { entry: './path/to/my/entry/file.js', output: { filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.(js|jsx)$/, use: 'babel-loader' } ] }, plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin({template: './src/index.html'}) ] }; NODE API Using plugin configuration it. "},"concept/5-configuration.html":{"url":"concept/5-configuration.html","title":"1.5. 配置","keywords":"","body":"Table of Contents Configuration simple configuration Multiple configuration Using other Configuration Languages Configuration 这个配置是通过webpack基于它的定义属性来处理的. 因为它是标准的Nodejs commonjs 模块.你可以做: import other file, using require (...) use utilities on npm use js control flow expressions, eg. the ?: operator. use constants or variables for often used values. write and execute functions to generate a part of the configuration simple configuration Multiple configuration Using other Configuration Languages typescript coffeescript Babel JSX "},"concept/6-modules.html":{"url":"concept/6-modules.html","title":"1.6. 模块","keywords":"","body":"Table of Contents Modules What is a webpack module Supported module types Modules 模块化编程的一些基础概念. What is a webpack module 相比较 NODEJS 模块,webpack 模块可以表示他们的依赖. ES2015 import 声明 Commonjs require 声明 AMD define and require 声明 在 css/sass/less file里面的 @import 声明 样式表中的 image URL ,like url(...) 或者 HTML里面的 …>= file. Supported module types 预处理器. CoffeeScript TypeScript ESNext Sass Less Stylus Elm "},"concept/7-module-resolution.html":{"url":"concept/7-module-resolution.html","title":"1.7. 模块解析","keywords":"","body":"Table of Contents module resolution resolving rules in webpack Resolving Loaders Caching module resolution 一个解析器是一个库.通过绝对路径来定位模块. import foo from 'path/to/module'; // or require('path/to/module'); 这个依赖模块可能来自应用代码,也可能来自第三方库. 解析器帮助webpack发现模块的代码,对于每一个 require/import 声明需要被包含在捆绑包当中. 在捆绑模块的时候,webpack 使用 enhanced-resolve 来解析文件路径 resolving rules in webpack Using enhanced-resolve , webpack可以解析三种类型的文件路径. Absolute Paths import '/home/me/file'; import 'C:\\Users\\me\\file'; Relative Paths import '../src/file1'; import './file2'; Module paths import 'module'; import 'module/lib/file'; 模块会搜索 所有由=resolve.modules= 指定的目录. 你可以替换origin module 路径,只需要通过一个备用路径: 使用 resolve.alias 配置选项创建一个alias. 一旦路径基于上面的规则被解析,解析器会检查看这个path point 是一个文件还是目录,如果 path point 是一个文件: 如果path 是一个文件扩展,那这个文件会直接被捆绑. 如果这个 file extension 使用 resolve.extension 选项来进行解析,这将告诉解析器,这个extensions 被解析过程所认同.比如说: .js /.jsx 如果 path point 是一个文件夹,下面的一步一步是在正确的extension中发现正确的file. 如果folder包含一个 package.json 文件,接下来这个字段通过指定=resolve.mainfields= 配置选项来有序查看,第一个字段 package.json 明确文件路径. 如果没有 package.json 文件,或者 resolve.mainField 没能返回一个有效的路径, resolve.mainFiles 配置选项中指定的file name会被有序查看, 主要看下 importted/required 的目录里,正在匹配的文件名是否存在. file extension 以同样的方式使用 resolve.extensions 选项被解析. webpack 根据你的构建对象提供合理的选项. Resolving Loaders 对文件解析的同种规则也是由其所指定.但是 这个 resolveLoader 配置选项可以对 loaders 用于分离解析规则. Caching 每一个文件系统的访问被缓存,所以对同一个文件的多个并行或连续请求响应更快. 在 watch mode ,只有被修改的文件会从缓存中被剔除.如果 watch mode 关闭了,这些缓存将会在每次编译之前被清除. 可以看下 Resolve API 来了解更多mentioned above 的配置选项. "},"concept/8-modeule-federation.html":{"url":"concept/8-modeule-federation.html","title":"1.8. 模块联盟","keywords":"","body":"Table of Contents Module Federation Motivation(动机) Low level concepts Overriding High-level concepts Building blocks Concept goals Use Cases Separate builds per page Components library as container Module Federation Motivation(动机) 应该从单一应用中进行多个分离构建. 这些分离构建彼此不必相互依赖,所以它们可以单独的被部署和构建. Low level concepts 我们区分local 和 remote 模块. local 模块是正常的模块,即当前构建的一部分. remote模块 不是当前构建的一部分,它来自于容器,在运行时被载入. 载入到远程模块被视为异步操作.当我们使用一个远程模块的时候,这个异步操作会被替代.这出现在下一个组块载入操作系统中的时候. 没有组块正在载入操作系统,它是不可能使用远程模块的. 一个chunk 载入操作系统通常使用 import() 调用,但是 旧版结构像 require.ensure or require([...]) 也被支持. container 通过 container entry 来创建, container entry 公开异步访问到指定模块.这种公开访问分为 2个步骤: 异步载入这个模块. 同时评估这个模块. 步骤1 在 chunk 载入的期间完成,步骤 2在和其他(local/remote) 模块交叉评估的过程中完成. 这种方式下,从 local 到 remote 来(或者其他方式)来转换一个模块,评估顺序是不受影响的, 嵌套一个container是有可能的.Containers 可以从其他Containers使用模块. 容器之间的循环依赖也是可能的. Overriding Container 可以标记选定的local模块成为 \"overridable\" (可被覆写的). container 的消费者可以提供 \"overrides\" (方法重载),这可以让模块替换容器中的 override 模块组中的一个. 只要消费者提供 方法重载, container 中的所有模块都可以使用可替换的模块,来替代 local module. 但消费者若不提供一个替换模块,container中的所有模块将使用本地模块. Container 管理 override 模块, 这种方式是: 当模块通过消费者被覆写的时候,这些模块不需要被下载.通过在分离的chunk中来放置替换模块. 另外一方面,替换模块的提供者,只提供 异步载入函数.它允许 container 来载入替换模块(只是它们在需要的情况下). 提供者将会管理替换模块,它们不通过container请求,所以它们不必被下载.通过在分离的chunk中来放置替换模块. 一个 \"name\" 被用于校验来自 container 的覆写模块. 容器 exposes (公开) 模块的时候,以一种类似的方式提供覆写,分为两个步骤: loading (异步) evaluating (异步) 当嵌套使用的时候,在嵌套的containers中,给一个container提供覆写 将会自动覆写这些模块. 在容器中的模块被载入之前覆写必须被提供. 可覆盖对象在初始化 chunk 被使用,只可以通过同步模块覆写方式来进行覆盖.不能使用promise. 一旦评估,可覆盖对象就不能被覆写了. High-level concepts 每个构建动作都充当容器,消耗其他构建也会充当容器. 每一次构建,通过从它的容器载入,可以访问任何其他公开模块. Building blocks OverridablesPlugin [low level] 这个plugin 让指定的模块 \"override\". A local API (webpackoverride) 允许提供 overrides // webpack.config.js // ------------------------------------- const OverridablesPlugin = require('webpack/lib/container/OverridablesPlugin'); module.exports = { plugins: [ new OverridablesPlugin([ { // we define an overridable module with OverridablesPlugin test1: './src/test1.js', }, ]), ], }; // src/index.js // ------------------------------- __webpack_override__({ // here we override test1 module test1: () => 'I will override test1 module under src', }); ContainerPlugin[low level] ContainerReferencePlugin [low level] ModuleFederationPlugin[high level] Concept goals 应该尽可能的公开和使用webpack支持的任何模块类型 Chunk 载入的过程中应该载入并行过程需要的一切.(到服务器的单个往返) 控制消费者到容器 覆写模块是一个定向操作 Sibling Containers 不能覆写彼此间的其他模块. Concept 应该环境独立 1.可用的web,nodejs,etc Use Cases Separate builds per page 从容器里分离构建的单页面应用的每一页都是公开的. 这个应用shell也是作为remote module来分离构建引用所有的页面. 这样每一页都能被分别部署.这个应用shell通常使用库来定义,作为共享modules来避免页面构建中重复. Components library as container 很多应用共享一个 common components 库,这个库可以被构建成每个组件公开的container. 每个应用的消费组件来自于组件库容器. 改变组件库可以分别部署,而不需要重新发布应用.这个应用自动使用组件库的升级版本. "},"concept/9-dependency-graph.html":{"url":"concept/9-dependency-graph.html","title":"1.9. 依赖图示","keywords":"","body":"Table of Contents Dependency Graph Dependency Graph 任意时间一个文件依赖于其他文件,webpack将其视为一个依赖.这允许webpack来携带非代码资产,比如说 images/web fonts,在应用上也可以提供他们作为依赖. 当webpack引导你的应用的时候,它从位于命令行或者它的配置文件的模块列表定义开始. 也就是从 entry point 开始,webpack 递归的构建依赖图示,这些图示包含应用中需要的每个模块,接下来将这些模块全部捆绑到少数捆绑包当中.浏览器通常只载入一次. 捆绑应用对于HTTP/1.1 client 相当牛逼,因为在浏览器开始一个新的请求的时候,它最小化了APP的等待时间, 对于 http/2,你可以使用代码切割 来实现比较好的结果. "},"concept/10-target.html":{"url":"concept/10-target.html","title":"1.10. 目标","keywords":"","body":"Table of Contents Target Usage Multi Targets Resources Target 因为JS可以对所有服务器和浏览器写入,webpack提供了多个部署对象,你可以在你的webpack 配置里面设置. webpack target 属性不能和 output.libraryTarget 属性相混淆. Usage 要想设置 target 属性,需要在webpack config 里面简单设置 target 值: module.exports = { target: 'node' }; 使用 node webpack将会在NODEJS 环境下 编译使用. (使用 node.js 的require 将会载入 chunks 并不会触及任何内置于模块的内容. 比如: fs / path) 每个 target 有多重 部署/环境指定附加项,满足它的需要. Multi Targets 尽管webpack 不支持多行字符串 来传递 target 属性,你可以创建一个 同构(isomorphic) 库,使用两个分离的配置就可以做到: const path = require('path'); const serverConfig = { target: 'node', output: { path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' } //… }; const clientConfig = { target: 'web', // 上面的这个例子将会在 dist 文件中 创建 lib.js 和 lib.node.js . Resources 还有很多部署对象供你选择,你可以看下下面的例子 compare-webpack-target-bundles boilerplate of electron - react application "},"concept/11-manifest.html":{"url":"concept/11-manifest.html","title":"1.11. 清单","keywords":"","body":"Table of Contents The Manifest(清单) Runtime Manifest The problem The Manifest(清单) 使用webpack构建一个典型应用/网站,这里面有三种类型的代码: 你自己的源代码. 第三方库的代码. 3.webpack的 runtime 和manifest,来指导所有模块的交互. Runtime runtime,处在 manifest data之间, 是webpack所有代码里的基本,当运行在浏览器中的时候,需要连接你的模块化应用. 它包含loading 和 resolving 逻辑 需要连接你的模块作为他们的交流. 这包含正在连接的模块,已经被载入到浏览当中,以及逻辑上的延迟加载那些没有连接的模块. Manifest 一旦你的应用在=index.html= 文件形式中,点击浏览器, 一些捆绑包和其他类型的assets会被应用需要,必须被载入和以某种方式链接. 你精心设置的 src 目录现在被捆绑,压缩,甚至可能通过webpack的 optimization 延迟加载 分割为更小的chunks. 那么webpack如何管理required 模块的彼此之间的交流哪?这就是为什么要谈到 manifest. 当编译入口,解析,并映射到应用,webpack 在所有的模块上面保持了详细的笔记. 这些收集的信息被称为 \"manifest\", 在运行时将使用解析和载入模块,一旦它们被捆绑和运送到浏览器当中. 无论你选择哪个模块语法,那些 =import= 或者 =require= 声明 现在变成 =__webpackl_require__= 方法(用于指向模块标识符) 使用manifest中的数据,runtime 将会找出从哪检索标识符后面的模块. The problem 现在你有一点关于webpack场景背后工作的一些见解. 但是它跟自己有毛关系哪? runtime webpack做自己的事情,运用清单,每件事都将会发生,一旦你的应用点击了浏览器. 如果你想要提高你的项目的性能,比如通过运用浏览器缓存,这个进程突然成为一个需要理解的重要事情. 通过在你的 捆绑文件名中 运用content hash,当文件内容发生改变的时候,你可以指示浏览器缓存无效. 一旦你开始使用,你将立即注意到这些有趣的行为. 即便他们的内容没有明显的改变,某些hashes的也会改变. 这是由runtime的注入和每次构建改变的manifest 造成的 . TODO: 1.extract the manifest 2.caching "},"concept/12-hot-modeule-replacement.html":{"url":"concept/12-hot-modeule-replacement.html","title":"1.12. HMR","keywords":"","body":"Table of Contents Hot module replacement How It works In the application In the compiler In a Module In the Runtime Hot module replacement Hot Module Replacement (HMR) exchange,adds,or removes module while an applications is running, without a full reload. This can sinigicantly speed up development in a few ways: 保持全部重载期间丢失的应用状态 更新改变的部分来节省宝贵的开发时间 当修改的部分放到源代码中的CSS/JS 的时候,浏览器立即更新.这个效果就像在浏览器 dev tools 直接改变style一样. How It works In the application 下面的步骤允许模块在应用之外交流: 应用询问HMR runtime 检查更新. runtime 异步下载更新并通知应用. 应用接下来询问 runtime 来apply 更新内容. runtime 同步应用更新. 你可以设置HMR 以便于这个进程自动发生,对于更新,你也可以选择 require 用户注入来产生. In the compiler 除了正常的 assets之外,编译器需要发出一个 \"update\" 来告诉先前版本到新版本允许更新. 这个 \"update\" 由 两部分组成: 1.Updated manifest (JSON) 2.多个update chunk (JS) 这个 manifest 包含新的 compilation hash 和 所有update chunks的list. 每个chunk都含有全部更新模块的新代码.(或者是一个标识,来指示哪些模块被移除) 编译器确保模块的ID和chunk的IDs 和这些构建是一致的.通常编译器通常把这些IDs 存在内存当中.比如说(webpack-dev-server),但是也可能存在JSON file 当中. In a Module HMR是一个可选的功能,仅影响包含HMR code的模块. 一个很好的例子就是通过 style-loader 打补丁styling. 要想这个补丁正常工作, style-loader 实现了 HMR的 接口,当它通过HMR 接收到 update的时候,它将会用新的样式来替换旧的样式. 类似的,当在一个模块实现HMR接口的时候,你可以描述当模块更新的时候,什么应该发生. 但是,大多数情况下,并不强制在每个模块中写下HMR的代码. 如果一个模块没有HMR handlers,这个update就会略过. 这意味着单个 handler 可以更新一个完整的模块树.如果来自这个树的单个模块更新了,那么整个依赖集就会被重载. In the Runtime 对于模块系统的runtime,发出额外的代码来追踪 模块 parents 和 children.在管理方面,这个runtime支持两个方法: check 和 apply. check 让 http请求 来更新 manifest.如果请求失败了,更新无效.如果成功了,更新的chunks列表是不同于当前已经载入的chunks了. 对于每个已经载入的chunk,对应的更新chunk会被下载. 所有模块更新在runtime期间被存储.当所有更新的chunk下载完毕并准备应用的时候,runtime会跳转为 ready state. apply 方法标志所有更新的模块无效.对于每个无效的模块,它们需要在模块或者父级模块里面更新handler. 否则,无效标识将会省略并且无视父级模块.每个都会省略,直到APP的入口点或者模块收到带有更新handler. 如果从一个入口点被省略,那么这个进程就GG了. 之后所有无效的模块都会被处理(包含处理handler) 和 卸载. 当前的hash接下来会更新并且全部 accept 被调用的handlers. runtime 会跳转回 idle 状态,一切都将正常进行. "},"concept/13-why-webpack.html":{"url":"concept/13-why-webpack.html","title":"1.13. 为何使用webpack","keywords":"","body":"Table of Contents Why webpack Why webpack 使用一个物之前,先看下之前他们的面临的烂摊子. Thinking: 在浏览器运行JS有几个法? 1, 每个功能都写一个脚本. 毛病: 载入太多脚本,有网络问题 一个大JS文件. 毛病: 维护,可读性,范围,大小问题. 立即调用函数表达式(IIFE) Js modules happened form node,js webpack runs on Node,js, a javascript runtime that can be used in computers and servers outside a browser environment. commonjs come out and introduced require,which allows you to load and use a module in the current file. This solved scope issues out of the box by importing each module as it was needed, "}}